# 챕터 1. 객체, 설계

조영호님의 오브젝트: 코드로 이해하는 객체지향 설계의 객체, 설계를 읽고 정리하는 글입니다.

## 1. 티켓 판매 프로그램 예제
### 요구사항
1. 극장에 입장하려면 티켓이 필요하다.
2. 초대장을 소지하고 있는 사람은 초대장을 티켓으로 무료로 바꾼 뒤 입장.
3. 초대장이 없는 사람은 티켓을 구매해야만 입장.

위 요구사항을 토대로 나온 클래스 다이어그램은 아래와 같다.
![Alt text](/Object/ch_1/개선전.png)

<br/><br/>

## 2. 문제점
**소프트웨어 모듈이 가져야 하는 세 가지 기능** - _로버트 마틴, <클린 소프트웨어: 애자일 원칙과 패턴, 그리고 실천 방법>_
- 실행 중 제대로 동작해야 한다.
- 변경에 어렵지 않아야 한다.
- 코드를 읽는 사람이 쉽게 읽고 이해할 수 있어야 한다.<br/>
<br/>

현재 작성된 클래스 다이어그램에 따르면 동작은 제대로 하고있지만, 변경에 용이하지 않고 쉽게 이하기에는 어렵다.   
<br/>

**위 세가지 원칙을 잘 지키고 있는지 확인해보자.**<br/>

```java
public class Theater {
    private TicketSeller ticketSeller;
    ...

    public void enter(Audience audience) {
        if (audience.getBag().hasInvitation()) {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            audience.getBag().setTicket(ticket);
        } else {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());
            audience.getBag().setTicket(ticket);
        }
    }
}
```
<br/>

### 문제 1. 손님(Audience)과 판매원(TicketSeller)이 극장(Theater)에 종속되어있는 구조
- 소극장이 관람객의 가방을 허락도 없이 열어본다.
- 소극장이 판매원을 통하긴 하지만, 매표소에 접근해서 티켓과 금액을 마음대로 변경한다.
<br/>

이해 가능한 코드란, 그 동작이 우리의 예상에서 크게 벗어나지 않는 코드다.   
현실에서는 극장이 손님의 가방을 마음대로 열어보지 않고, 매표소의 티켓과 현금에 직접 관여를 하지 않고 판매원이 직접 한다.   
이게 우리가 알고 있는 상식인데, enter()에 작성되어있는 코드는 우리가 알고있는 상식과는 다르기 때문에 코드를 읽는 사람과의 의사소통이 어렵다.
<br/><br/>



### 문제 2. 코드를 이해하기 위해서 세부적인 내용들을 기억해야 한다.
enter() 메소드를 읽기 위해서 아래 내용을 모두 기억하고 있어야 한다.
- Audience가 Bag을 가지고있다.
- Bag 안에는 현금과 티켓이 있다.
- TicketSeller가 TicketOffice에서 티켓을 판매한다.
- TicketOffice에서 티켓과 돈을 보관한다.
<br/>

지금은 프로그램이 작아서 읽을 수 있다고 하지만, 프로그램이 커지게 되면 비효율적이며, 읽는데도 시간이 오래 걸리게 될 것이다.
<br/><br/>

### 문제 3. 변경에 취약한 코드
만약 손님이 가방이 아닌 지갑을 들고있다고 가정한다면
- Audience에서 Bag을 제거
- Audience의 Bag에 접근하는 Theater의 enter 메서드 수정
<br/>

또한 TicketSeller가 티켓값을 다른곳에 보관한다고 가정해도 수정되어야 할 부분이 있다.
<br/>

이 상황은 **의존성**과 관련이 있다.
-  **의존성**
    - 특정 객체가 변경될 때 그 객체에 의존하는 다른 객체도 함께 변경될 수 있다.
    - 객체간 서로 의존성이 과하게 연결된 경우 - **결합도(Coupling)가 높다**
    - 객체간 서로 의존성이 과하지 않은 경우 - **결합도(Coupling)가 낮다**
<br/>

객체지향 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것이기 때문에,
의존성을 완전히 없애는 것이 아닌, 기능을 구현하는데 최소한의 의존성만 유지하고 분리할 수 있는 의존성은 제거하는것이 좋은 설계이다.
<br/><br/>

## 3. 설계 개선하기

극장(Theater)이 손님(Audience)의 가방(Bag)과 판매원(TicketSeller)의 매표소(TicketOffice)에 직접 접근하는 문제는, 손님과 판매원이 자신의 일을 스스로 처리해야 한다는 상식을 벗어나기 떄문에 **의사소통이 어렵고**, 손님과 판매원을 변경할 때 극장도 함께 변경해야 하기 때문에 **변경이 어려워**진 것이다.
<br/>

### 3-1. 자율성을 높이자.
지금은 Theater에서 TicketSeller가 의존하고 있는 TicketOffice까지 접근할 수 있게 만들어져있기 때문에, TicketSeller가 할 수 있는 일은 Theater.enter에서 TicketSeller.sellTo라는 메서드를 만든 뒤 옮긴다.

```java
public class Theater {
    private TicketSeller ticketSeller;
    ...
    public void enter(Audience audience) {
        ticketSeller.sellTo(audience);
    }
}

public class TicketSeller {
    private TicketOffice ticketOffice;
    ...
    public void sellTo(Audience audience) {
        if (audience.getBag().hasInvitation()) {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            audience.getBag().setTicket(ticket);
        } else {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());
            audience.getBag().setTicket(ticket);
        }
    }
    // public TicketOffice getTicketOffice() { ... }

}
```
- 이제 외부에서 TicketSeller를 통해 TicketOffice를 참조하지 못하게 getTicketOffice() 메소드를 지웠다.
- Theater에서 TicketOffice로의 접근이 불가능해졌기 때문에, 두 객체 사이의 의존성은 제거됐고, TicketSeller 객체의 캡슐화에 성공했다. <br/>

 <br/>

![Alt text](/Object/ch_1/개선후.png)

이런 과정을 통해 하나하나 캡슐화를 해 나가다 보면 위와같이 클래스 다이어그램이 수정되고, 로버트 마틴이 주장한 세 가지 원칙도 지켜지게 된다.
- 실행 중 제대로 동작해야 한다. - **OK**

- 변경에 어렵지 않아야 한다. - **OK**
    - Audience가 가지고 다니는게 가방이 아닌 지갑으로 변경되어도 Audience의 내부만 변경하면 되고, **Audience를 참조하는 어떤 곳에도 변경이 일어날 필요가 없어졌다.**

- 코드를 읽는 사람이 쉽게 읽고 이해할 수 있어야 한다. - **OK**
    - Audience와 TicketSeller는 자신이 가지고 있는 소지품을 스스로 관리함으로써 우리의 상식과도 일치하기 때문에 **읽는 사람이 쉽게 이해할 수 있다**.

<br/>

**객체의 자율성을 높이면 이해하기 쉽고, 유연한 설계를 얻을 수 있다.**

<br/><br/><br/>

### 3-2. 캡슐화와 응집도

**객체 내부의 상태를 캡슐화 하고 객체간에 오직 메시지를 통해서만 상호작용 하도록 만들게 되면 결합도는 낮아지고, 응집도는 높아지게 되는 결과를 얻게 된다.**
<br/>

객체는 자신이 소유하고 있는 데이터에 대해서만 처리를 해야지 자신이 의존하고 있고, 접근할 수 있다고해서 굳이 의존하는 객체의 내부까지 침투해서 데이터를 끌어다가 사용하고 변경하게 되버리면 두 객체 사이의 결합도는 올라가고, 시작하는 객체에서 다른 객체까지 행동 반경이 넓어지기 때문에 응집도는 낮아지게 된다. 
<br/>

아까 우리가 알고있는 상식에 비유해서 표현했는데, 판매원이 손님이 가지고있는 가방을 뒤지는걸 상황이랑 같다고 생각한다.
<br/>

손님은 자신의 가방을 직접 뒤져야지 판매원이 뒤적거리면 우리가 알고있는 상식과 다르게 되어버린다. 이렇게 되면 판맨원은 손님이 가지고있는게 가방이 아닌 지갑이나 심지어는 주머니만 가지고 있다고 가정하면, 이 모든 사실을 판매원은 알아야 하는 상황인 것이다.
<br/>

이렇기 때문에 객체는 자신이 가지고 있는 데이터만을 처리해야 우리가 알고있는 상식과도 일치하면서 변경에도 용이해지게 되는 것이다.

#### 캡슐화 (Encapsulation)
- 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것
- 변경하기 쉬운 객체를 만드는 것이 목적
- 캡슐화를 통해 내부로의 접근을 제한하면 결합도를 낮출 수 있기 때문에 설계를 좀 더 쉽게 변경할 수 있게 된다. ex) getter, setter

#### 응집도 (Cohesion)
- 한 모듈 내부의 요소들이 서로 관련되어 있는 정도.
- 밀접하게 연관된 작업만 수행하고, 연관성 없는 작업은 다른 객체에 위임하는 것: 높은 응집도
- 얼마나 밀접한지와는 상관 없이 연관되어 있는 객체의 모든 작업을 직접 처리하는 것: 낮은 응집도

<br/><br/>

### 3-3. 절차지향과 객체지향

#### 절자치향 (Procedural Programming)
- 개선하기 전의 구조처럼 프로세스와 데이터를 별도의 모듈에 위치시키는 방식
- 개체를 순차적으로 처리하여 프로그램 전체가 유기적으로 연결되어있는 방식
    - 프로세스: Theater.enter
    - 데이터: Audience, TicketSeller, Bag, TicketOffice


- **문제점**
    - 직관에 위배되기 때문에, 코드를 읽는 사람돠 의사소통이 원활하지 않다.
    - 변경에 취약한 코드가 만들어진다.
        - Theater 객체가 의존하고 있는 객체가 많기 때문에 의존하는 곳에서 변경이 일어나면, Theater도 함께 변경을 해야하는데 이런 상황에서는 버그가 언제든지 나타날 수 있다.

#### 객체지향 (Object-oriented Programming)

- #### **변경하기 쉬운 설계는 한번에 하나의 클래스만 변경할 수 있는 설계다.**

- 데이터와 프로세스가 동일한 모듈 내부에 위치시키는 방식
- 캡슐화를 이용해 의존성을 **적절히** 관리하여 객체 사이의 결합도를 낮추는 것.   
<br/>

위에서 얘기한 것 처럼 객체지향 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것이기 때문에, 의존성을 완전히 없애는 것이 아닌 정답이 아니고, 의존성과 결합도 사이에서 **적절한 트레이드 오프**를 통해 설계를 풀어나가는게 좋은 방법이다.

<br/> <br/>

### 3-4. 책임의 이동 (Shift of Responsibility)
두 방식의 근본적인 차이를 만드는 것은 책임의 이동이다.   

**절차적** - 모든 책임을 Theater가 맡아서 처리   
**객체지향** - 각 객체가 자신이 맡은 일을 스스로 처리

- 자신의 **책임을 스스로 처리**
- 객체가 어떤 데이터를 가지느냐 보다는, **객체에 어떤 책임을 할당할 것이냐**에 초점을 맞춰야 함
- **적절한 객체에 적절한 책임을 할당**하면 이해하기 쉬운 구조와 읽기 쉬운 코드를 얻는다.
- 설계를 어렵게 만드는 것은 의존성이다.   
  객체 내의 **불필요한 의존성을 제거**함으로써 **객체 사이의 결합도를 낮춰**야 한다.

<br/><br/>

## 4. 좋은 설계란?

우리가 만드는 프로그램은 두 가지 요구사항을 만족시켜야 한다.   
1. 일정 기간 안에 완성해야 하는 기능을 구현해내는 것.
2. 오늘 구현한 기능을 내일 쉽게 변경할 수 있는 코드를 만드는 것.

변경을 수용할 수 있는 설계가 중요한 이유는 요구사항이 항상 변경되기 때문이다.   
요구사항은 언제든지 변할 수 있기 때문에 처음부터 완벽한 설계를 한다는 것은 불가능하다.   

